This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-28T17:56:30.229Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
CombatFramework.Target.cs
CombatFramework/CombatFramework.Build.cs
CombatFramework/CombatFramework.cpp
CombatFramework/CombatFramework.h
CombatFramework/Private/Character/CF_Character.cpp
CombatFramework/Private/Component/CF_StateBase.cpp
CombatFramework/Private/Component/CF_StateManager.cpp
CombatFramework/Private/Component/CombatComponent.cpp
CombatFramework/Private/Enums/GameEnums.cpp
CombatFramework/Private/Notifiers/ComboTimeNotify.cpp
CombatFramework/Private/Notifiers/ProperHitNotify.cpp
CombatFramework/Private/Notifiers/SwitchActionState.cpp
CombatFramework/Private/StateMachines/AI/States/HitAIState.cpp
CombatFramework/Private/StateMachines/AI/States/IdleAIState.cpp
CombatFramework/Private/StateMachines/Player/States/AttackPlayerState.cpp
CombatFramework/Private/StateMachines/Player/States/IdlePlayerState.cpp
CombatFramework/Private/Structs/Sequence.cpp
CombatFramework/Public/Character/CF_Character.h
CombatFramework/Public/Component/CF_StateBase.h
CombatFramework/Public/Component/CF_StateManager.h
CombatFramework/Public/Component/CombatComponent.h
CombatFramework/Public/Enums/GameEnums.h
CombatFramework/Public/Notifiers/ComboTimeNotify.h
CombatFramework/Public/Notifiers/ProperHitNotify.h
CombatFramework/Public/Notifiers/SwitchActionState.h
CombatFramework/Public/StateMachines/AI/States/HitAIState.h
CombatFramework/Public/StateMachines/AI/States/IdleAIState.h
CombatFramework/Public/StateMachines/Player/States/AttackPlayerState.h
CombatFramework/Public/StateMachines/Player/States/IdlePlayerState.h
CombatFramework/Public/Structs/GameStructs.h
CombatFramework/Public/Structs/Sequence.h
CombatFrameworkEditor.Target.cs

================================================================
Repository Files
================================================================

================
File: CombatFramework.Target.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class CombatFrameworkTarget : TargetRules
{
	public CombatFrameworkTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V5;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_4;
		ExtraModuleNames.Add("CombatFramework");
	}
}

================
File: CombatFramework/CombatFramework.Build.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class CombatFramework : ModuleRules
{
	public CombatFramework(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[]
			{ "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "ALS", "CustomStateMachine", "MotionWarping" });

		PrivateDependencyModuleNames.AddRange(new string[] {  });

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

================
File: CombatFramework/CombatFramework.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.

#include "CombatFramework.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, CombatFramework, "CombatFramework" );

================
File: CombatFramework/CombatFramework.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

================
File: CombatFramework/Private/Character/CF_Character.cpp
================
// M T All rights Reserved


#include "Character/CF_Character.h"

#include "EnhancedInputComponent.h"
#include "Component/CF_StateManager.h"
#include "Component/CombatComponent.h"
#include "MotionWarpingComponent.h"
#include "StateMachines/AI/States/HitAIState.h"
#include "StateMachines/AI/States/IdleAIState.h"
#include "StateMachines/Player/States/AttackPlayerState.h"
#include "StateMachines/Player/States/IdlePlayerState.h"

ACF_Character::ACF_Character(): CurrentComboSequence(nullptr)
{
	PrimaryActorTick.bCanEverTick = true;

	// StateManagerComponent = CreateDefaultSubobject<UCF_StateManager>(TEXT("CF_StateManagerComponent"));
	// StateManagerComponent->bDebug = true;
}

void ACF_Character::BeginPlay()
{
	Super::BeginPlay();

	CombatComponent = FindComponentByClass<UCombatComponent>();
	checkf(CombatComponent, TEXT("CombatComponent is null"));
	
	CombatComponent->SetMesh(GetMesh());

	StateManagerComponent = FindComponentByClass<UCF_StateManager>();
	checkf(StateManagerComponent, TEXT("StateManagerComponent is null"));

	MotionWarpingComponent = FindComponentByClass<UMotionWarpingComponent>();
	
	if (IsPlayerControlled())
	{
		UIdlePlayerState* IdleState = NewObject<UIdlePlayerState>(this, UIdlePlayerState::StaticClass());
		UAttackPlayerState* AttackState = NewObject<UAttackPlayerState>(this, UAttackPlayerState::StaticClass());

		StateManagerComponent->AddActionState(ECF_ActionState::Idle, IdleState);
		StateManagerComponent->AddActionState(ECF_ActionState::Attack, AttackState);

		StateManagerComponent->SwitchActionState(ECF_ActionState::Idle);
	}
	else
	{
		UIdleAIState* IdleState = NewObject<UIdleAIState>(this, UIdleAIState::StaticClass());
		UHitAIState* HitState = NewObject<UHitAIState>(this, UHitAIState::StaticClass());

		StateManagerComponent->AddActionState(ECF_ActionState::Idle, IdleState);
		StateManagerComponent->AddActionState(ECF_ActionState::Hit, HitState);

		StateManagerComponent->SwitchActionState(ECF_ActionState::Idle);
	}
}

void ACF_Character::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);
}

void ACF_Character::SetupPlayerInputComponent(UInputComponent* Input)
{
	Super::SetupPlayerInputComponent(Input);

	auto* EnhancedInput{Cast<UEnhancedInputComponent>(Input)};
	if (IsValid(EnhancedInput))
	{
		EnhancedInput->BindAction(LightAttackAction, ETriggerEvent::Triggered, this, &ThisClass::Input_OnLightAttack);
	}
}

void ACF_Character::SetCombatComponent(UCombatComponent* InCombatComponent,
	USkeletalMeshComponent* InSkeletalMeshComponent)
{
	CombatComponent = InCombatComponent;
	CombatComponent->SetMesh(InSkeletalMeshComponent);
}

void ACF_Character::Input_OnLightAttack(const FInputActionValue& InputActionValue)
{
	if (InputActionValue.Get<bool>())
	{
		// Display current action state:
		// UE_LOG(LogTemp, Warning, TEXT("Current Action State: %s"), *UEnum::GetValueAsString(StateManagerComponent->GetActionState()));
		
		if (StateManagerComponent->GetActionState() == ECF_ActionState::Attack)
		{
			CombatComponent->SaveNextAttack();
		}
		else
		{
			CombatComponent->PrepareAttack();
		}
	}
}

================
File: CombatFramework/Private/Component/CF_StateBase.cpp
================
// M T All rights Reserved


#include "Component/CF_StateBase.h"

#include "Component/CF_StateManager.h"

void UCF_StateBase::SetStateManager(UStateManagerComponent* InStateManager)
{
	Super::SetStateManager(InStateManager);

	StateManager = Cast<UCF_StateManager>(InStateManager);
	checkf(StateManager, TEXT("Can't find UCF_StateManager"));
}

================
File: CombatFramework/Private/Component/CF_StateManager.cpp
================
// M T All rights Reserved


#include "Component/CF_StateManager.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateBase.h"

void UCF_StateManager::BeginPlay()
{
	Super::BeginPlay();

	CurrentCharacter = Cast<ACF_Character>(GetOwner());
	checkf(CurrentCharacter, TEXT("Can't find ACF_Character"));
}

void UCF_StateManager::SwitchState(UStateBase* NewState)
{
	Super::SwitchState(NewState);

	if (auto CustomState = Cast<UCF_StateBase>(NewState))
	{
		CurrentActionState = CustomState->State;
	}
}

UStateBase* UCF_StateManager::GetExistingStateByKey(const FString& Key) const
{
	if (StateMap.Contains(Key))
	{
		return Cast<UStateBase>(StateMap.FindRef(Key));
	}

	UE_LOG(LogTemp, Error, TEXT("Can't find State with key: %s"), *Key);
	
	return nullptr;
}

UStateBase* UCF_StateManager::GetExistingState(ECF_ActionState ActionState) const
{
	if (ActionStateMap.Contains(ActionState))
	{
		return Cast<UStateBase>(ActionStateMap.FindRef(ActionState));
	}

	PrintDebugMessage(FString::Printf(TEXT("Can't find State")));
	return nullptr;
}

void UCF_StateManager::AddActionState(const ECF_ActionState ActionState, UCF_StateBase* State)
{
	// Add the state to the map
	State->SetStateManager(this);
	State->State = ActionState;
	State->StateDisplayName = FName(UEnum::GetValueAsString(ActionState));
	ActionStateMap.Add(ActionState, State);
}

void UCF_StateManager::SwitchActionState(const ECF_ActionState ActionState)
{
	if (ActionStateMap.Contains(ActionState))
	{
		UCF_StateBase* NewState = ActionStateMap.FindRef(ActionState);
		CurrentActionState = ActionState;
		SwitchState(NewState);
	}
	else
	{
		PrintDebugMessage(FString::Printf(TEXT("UCF_StateManager::SwitchState: Action state not found")));
	}
}

================
File: CombatFramework/Private/Component/CombatComponent.cpp
================
// M T All rights Reserved


#include "Component/CombatComponent.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"
#include "StateMachines/Player/States/AttackPlayerState.h"
#include "Structs/GameStructs.h"

// Sets default values for this component's properties
UCombatComponent::UCombatComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = false;

	AActor* Owner = GetOwner();
	if (ACF_Character* Character = Cast<ACF_Character>(Owner))
	{
		CharacterCached = Character;
	}

	NextAttack = false;

}

void UCombatComponent::PrepareAttack()
{
	NextAttack = false;
	CheckComboSequence();
}

void UCombatComponent::SetMesh(USkeletalMeshComponent* InSkeletalMeshComponent)
{
	SkeletalMeshComponent = InSkeletalMeshComponent;
}

USkeletalMeshComponent* UCombatComponent::GetSkeletalMeshComponent() const
{
	return SkeletalMeshComponent;
}

void UCombatComponent::MontageFinished()
{
	CurrentMontage = nullptr;
}

void UCombatComponent::BreakCombo()
{
	CurrentComboIndex = -1;
}

void UCombatComponent::SaveNextAttack()
{
	NextAttack = true;
}

void UCombatComponent::CheckComboSequence()
{
	if (CurrentComboIndex < 0)
	{
		TArray<FSequence*> TempAttackSequences;
		AttackSequences->GetAllRows<FSequence>("CombatComponent", TempAttackSequences);

		int randomIndex = FMath::RandHelper(TempAttackSequences.Num());
		CurrentComboSequence = *TempAttackSequences[randomIndex];
		CurrentComboIndex = 0;
	}

	NormalAttack();
}

void UCombatComponent::NormalAttack()
{
	if (CurrentComboIndex < CurrentComboSequence.AttackMontages.Num())
	{
		Attack(CurrentComboSequence.AttackMontages[CurrentComboIndex]);
		CurrentComboIndex++;
	}
	else
	{
		BreakCombo();
		CheckComboSequence();
	}
}

void UCombatComponent::Attack(UAnimMontage* AttackMontageToPlay) const
{
	if (CurrentMontage)
	{
		UE_LOG(LogTemp, Warning, TEXT("Montage already exists"));
		return;
	}

	if (auto AttackState = Cast<UAttackPlayerState>(
		CharacterCached->GetStateManager()->GetExistingState(ECF_ActionState::Attack)))
	{
		AttackState->AttackData = FAttackPlayerStateBaseData(AttackMontageToPlay);
		CharacterCached->GetStateManager()->SwitchActionState(ECF_ActionState::Attack);
	}
}

================
File: CombatFramework/Private/Enums/GameEnums.cpp
================
// M T All rights Reserved


#include "Enums/GameEnums.h"

================
File: CombatFramework/Private/Notifiers/ComboTimeNotify.cpp
================
// M T All rights Reserved


#include "Notifiers/ComboTimeNotify.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"

void UComboTimeNotify::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation,
                              const FAnimNotifyEventReference& EventReference)
{
	Super::Notify(MeshComp, Animation, EventReference);

	AActor* AnimationOwner = MeshComp->GetOwner();
	if (const ACF_Character* Character = Cast<ACF_Character>(AnimationOwner))
	{
		Character->GetStateManager()->OnComboTime.Broadcast();
	}
}

================
File: CombatFramework/Private/Notifiers/ProperHitNotify.cpp
================
// M T All rights Reserved


#include "Notifiers/ProperHitNotify.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"


void UProperHitNotify::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation,
	const FAnimNotifyEventReference& EventReference)
{
	Super::Notify(MeshComp, Animation, EventReference);

	AActor* AnimationOwner = MeshComp->GetOwner();
	if (ACF_Character* Character = Cast<ACF_Character>(AnimationOwner))
	{
		Character->GetStateManager()->OnProperHit.Broadcast(HitMontage);
	}
}

================
File: CombatFramework/Private/Notifiers/SwitchActionState.cpp
================
// M T All rights Reserved


#include "Notifiers/SwitchActionState.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"

void USwitchActionState::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation,
                                const FAnimNotifyEventReference& EventReference)
{
	Super::Notify(MeshComp, Animation, EventReference);

	AActor* AnimationOwner = MeshComp->GetOwner();
	if (ACF_Character* Character = Cast<ACF_Character>(AnimationOwner))
	{
		// Character->GetStateManager()->SwitchState(NewState, nullptr);
	}
}

================
File: CombatFramework/Private/StateMachines/AI/States/HitAIState.cpp
================
// M T All rights Reserved


#include "StateMachines/AI/States/HitAIState.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"

void UHitAIState::OnEnterState(AActor* Owner)
{
	Super::OnEnterState(Owner);
	
	auto CurrentCharacter = StateManager->GetCharacter();

	CurrentCharacter->GetMesh()->GetAnimInstance()->Montage_Play(HitData.HitMontage, 1.0f);
	MontageEndedDelegate.BindUObject(this, &UHitAIState::OnMontageEnded);
	CurrentCharacter->GetMesh()->GetAnimInstance()->Montage_SetEndDelegate(MontageEndedDelegate, HitData.HitMontage);
}

void UHitAIState::OnExitState()
{
	Super::OnExitState();

	MontageEndedDelegate.Unbind();
}

void UHitAIState::OnMontageEnded(UAnimMontage* AnimMontage, bool bInterrupted) const
{
	if (!AnimMontage->GetName().Equals(HitData.HitMontage->GetName()))
	{
		return;
	}
	
	StateManager->SwitchActionState(ECF_ActionState::Idle);
}

================
File: CombatFramework/Private/StateMachines/AI/States/IdleAIState.cpp
================
// M T All rights Reserved


#include "StateMachines/AI/States/IdleAIState.h"

================
File: CombatFramework/Private/StateMachines/Player/States/AttackPlayerState.cpp
================
// M T All rights Reserved


#include "StateMachines/Player/States/AttackPlayerState.h"

#include "MotionWarpingComponent.h"
#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"
#include "Component/CombatComponent.h"
#include "Components/CapsuleComponent.h"
#include "Engine/OverlapResult.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Kismet/GameplayStatics.h"
#include "StateMachines/AI/States/HitAIState.h"
#include "StateMachines/Player/States/IdlePlayerState.h"

UAttackPlayerState::UAttackPlayerState(): IsAttackContinuing(false), TargetCharacterOldCollision()
{
	bCanTick = false;
	bCanRepeat = true;

	State = ECF_ActionState::Attack;
}

void UAttackPlayerState::OnEnterState(AActor* Owner)
{
	Super::OnEnterState(Owner);

	auto CurrentCharacter = StateManager->GetCharacter();
	
	StateManager->OnProperHit.AddUObject(this, &UAttackPlayerState::OnProperHitCallback);
	StateManager->OnComboTime.AddUObject(this, &UAttackPlayerState::OnComboTimeCallback);

	CurrentCharacter->PlayAnimMontage(AttackData.AttackMontage, 1.0f);
	MontageEndedDelegate.BindUObject(this, &UAttackPlayerState::OnMontageEnded);
	CurrentCharacter->GetMesh()->GetAnimInstance()->Montage_SetEndDelegate(MontageEndedDelegate, AttackData.AttackMontage);
	
	FVector Origin = CurrentCharacter->GetActorLocation();
	TSubclassOf<AActor> SearchClass = ACF_Character::StaticClass();
	
	if (AActor* NearestActor = GetNearestActorUsingOverlap(CurrentCharacter->GetWorld(), Origin, 500, SearchClass))
	{
		if (ACF_Character* NearestAcfCharacter = Cast<ACF_Character>(NearestActor))
		{
			TargetCharacter = NearestAcfCharacter;
			TargetCharacterOldCollision = TargetCharacter->GetCapsuleComponent()->GetCollisionEnabled();
			TargetCharacter->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::Type::QueryOnly);

			FVector TargetDirection = TargetCharacter->GetActorLocation() - StateManager->GetCharacter()->GetActorLocation();
			TargetDirection.Normalize();
			const FRotator TargetRotation = FRotationMatrix::MakeFromX(TargetDirection).Rotator();
			const FVector TargetPosition = TargetCharacter->GetActorLocation() - TargetDirection * 100;
			StateManager->GetCharacter()->GetMotionWarpingComponent()->AddOrUpdateWarpTargetFromLocationAndRotation(
				"AttackTarget", TargetPosition, TargetRotation);
			
		}
	}
}

void UAttackPlayerState::OnExitState()
{
	Super::OnExitState();

	StateManager->GetCharacter()->GetMotionWarpingComponent()->RemoveAllWarpTargets();
	
	StateManager->OnProperHit.Clear();
	StateManager->OnComboTime.Clear();
	MontageEndedDelegate.Unbind();

	if (TargetCharacter)
	{
		TargetCharacter->GetCapsuleComponent()->SetCollisionEnabled(TargetCharacterOldCollision);
	}
	
	TargetCharacter = nullptr;
}

void UAttackPlayerState::OnProperHitCallback(UAnimMontage* HitMontage)
{
	if (HitMontage && TargetCharacter)
	{
		if (const UHitAIState* HitState = Cast<UHitAIState>(TargetCharacter->GetStateManager()->GetExistingState(ECF_ActionState::Hit)))
		{
			FHitStateBaseData HitData;
			HitData.HitMontage = HitMontage;
			TargetCharacter->GetStateManager()->SwitchActionState(ECF_ActionState::Hit);
		}
	}
}

void UAttackPlayerState::OnComboTimeCallback()
{
	if (StateManager->GetCharacter()->GetCombatComponent()->IsNextAttackSaved())
	{
		IsAttackContinuing = true;
		StateManager->GetCharacter()->GetCombatComponent()->PrepareAttack();
	}
	else
	{
		IsAttackContinuing = false;
	}
}

void UAttackPlayerState::OnMontageEnded(UAnimMontage* AnimMontage, bool bInterrupted) const
{
	if (!AnimMontage->GetName().Equals(AttackData.AttackMontage->GetName()))
	{
		return;
	}
	
	if (!IsAttackContinuing)
	{
		StateManager->SwitchActionState(ECF_ActionState::Idle);
	}
}

AActor* UAttackPlayerState::GetNearestActorUsingOverlap(const UWorld* World, const FVector& Origin, const float Radius,
                                                        const TSubclassOf<AActor>& ActorClass) const
{
	if (!World) return nullptr;

	// DrawDebugSphere(World, Origin, Radius, 12, FColor::Red, false, 5.f);
	TArray<FOverlapResult> OverlapResults;
	const FCollisionShape CollisionSphere = FCollisionShape::MakeSphere(Radius);
	FCollisionQueryParams QueryParams; // Correct
	QueryParams.AddIgnoredActor(StateManager->GetCharacter());
	QueryParams.bTraceComplex = false;

	// Perform the sphere overlap query
	if (World->OverlapMultiByObjectType(
			OverlapResults,
			Origin,
			FQuat::Identity,
			FCollisionObjectQueryParams(ECollisionChannel::ECC_Pawn), // Adjust channel as needed
			CollisionSphere,
			QueryParams))
	{
		AActor* NearestActor = nullptr;
		float NearestDistanceSq = FLT_MAX;

		for (const FOverlapResult& Result : OverlapResults)
		{
			AActor* OverlappedActor = Result.GetActor();
			if (OverlappedActor && OverlappedActor->IsA(ActorClass))
			{
				float DistanceSq = FVector::DistSquared(Origin, OverlappedActor->GetActorLocation());
				if (DistanceSq < NearestDistanceSq)
				{
					NearestDistanceSq = DistanceSq;
					NearestActor = OverlappedActor;
				}
			}
		}
		return NearestActor;
	}
	return nullptr; // No actors found
}

================
File: CombatFramework/Private/StateMachines/Player/States/IdlePlayerState.cpp
================
// M T All rights Reserved


#include "StateMachines/Player/States/IdlePlayerState.h"

#include "Character/CF_Character.h"
#include "Component/CF_StateManager.h"
#include "Component/CombatComponent.h"

UIdlePlayerState::UIdlePlayerState(): State(ECF_ActionState::Idle)
{
}

void UIdlePlayerState::OnEnterState(AActor* Owner)
{
	Super::OnEnterState(Owner);

	StateManager->GetCharacter()->GetCombatComponent()->BreakCombo();
}

================
File: CombatFramework/Private/Structs/Sequence.cpp
================
// M T All rights Reserved


#include "Structs/Sequence.h"

================
File: CombatFramework/Public/Character/CF_Character.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "AlsCharacterExample.h"
#include "CF_Character.generated.h"

class UCF_StateManager;
struct FSequence;
class UCombatComponent;
class UMotionWarpingComponent;
/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API ACF_Character : public AAlsCharacterExample
{

	GENERATED_BODY()
public:
	
	ACF_Character();

	virtual void BeginPlay() override;
	virtual void Tick(float DeltaSeconds) override;

	FORCEINLINE UCF_StateManager* GetStateManager() const { return StateManagerComponent; }
	FORCEINLINE TObjectPtr<UCombatComponent> GetCombatComponent() const { return CombatComponent; }
	FORCEINLINE TObjectPtr<UMotionWarpingComponent> GetMotionWarpingComponent() const { return MotionWarpingComponent; }

protected:

	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category= "CF Character Setup")
	TObjectPtr<UCombatComponent> CombatComponent;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Settings|CF Character", Meta = (DisplayThumbnail = false))
	TObjectPtr<UInputAction> LightAttackAction;
	
	virtual void SetupPlayerInputComponent(UInputComponent* Input) override;

	UFUNCTION(BlueprintCallable, Category = "CF Character")
	void SetCombatComponent(UCombatComponent* InCombatComponent, USkeletalMeshComponent* InSkeletalMeshComponent);

private:

	FSequence* CurrentComboSequence;

	void Input_OnLightAttack(const FInputActionValue& InputActionValue);

	TObjectPtr<UCF_StateManager> StateManagerComponent;
	TObjectPtr<UMotionWarpingComponent> MotionWarpingComponent;
};

================
File: CombatFramework/Public/Component/CF_StateBase.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "StateBase.h"
#include "Enums/GameEnums.h"
#include "CF_StateBase.generated.h"

class UCF_StateManager;
/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UCF_StateBase : public UStateBase
{
	GENERATED_BODY()

public:

	virtual void SetStateManager(UStateManagerComponent* InStateManager) override;
	
	ECF_ActionState State;

protected:
	UPROPERTY()
	UCF_StateManager* StateManager;
};

================
File: CombatFramework/Public/Component/CF_StateManager.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "StateManagerComponent.h"
#include "CF_StateManager.generated.h"


class UCF_StateBase;
class UStateBase;
class ACF_Character;
enum class ECF_ActionState : uint8;

DECLARE_MULTICAST_DELEGATE_OneParam(OnProperHitSignature, UAnimMontage*);
DECLARE_MULTICAST_DELEGATE(OnComboTimeSignature);

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class COMBATFRAMEWORK_API UCF_StateManager : public UStateManagerComponent
{
	GENERATED_BODY()

public:
	virtual void BeginPlay() override;
	virtual void SwitchState(UStateBase* NewState) override;
	UStateBase* GetExistingStateByKey(const FString& Key) const;
	UStateBase* GetExistingState(ECF_ActionState ActionState) const;

	OnProperHitSignature OnProperHit;
	OnComboTimeSignature OnComboTime;

	UFUNCTION(BlueprintCallable, Category = "State Machine")
	void AddActionState(ECF_ActionState ActionState, UCF_StateBase* State);

	UFUNCTION()
	void SwitchActionState(ECF_ActionState ActionState);
	
	FORCEINLINE ECF_ActionState GetActionState() const { return CurrentActionState; }
	FORCEINLINE ACF_Character* GetCharacter() const { return CurrentCharacter; }
private:

	ECF_ActionState CurrentActionState;

	UPROPERTY()
	ACF_Character* CurrentCharacter;

	UPROPERTY()
	TMap<ECF_ActionState, UCF_StateBase*> ActionStateMap;
};

================
File: CombatFramework/Public/Component/CombatComponent.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "Structs/Sequence.h"
#include "CombatComponent.generated.h"


class ACF_Character;

UCLASS(BlueprintType, Blueprintable, ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class COMBATFRAMEWORK_API UCombatComponent : public UActorComponent
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	UCombatComponent();
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Attack")
	TObjectPtr<UDataTable> AttackSequences;

	void PrepareAttack();
	void SetMesh(USkeletalMeshComponent* InSkeletalMeshComponent);

	UFUNCTION(BlueprintImplementableEvent)
	void PlayAnimation(UAnimMontage* MontageToPlay);

	UFUNCTION(BlueprintPure)
	USkeletalMeshComponent* GetSkeletalMeshComponent() const;

	UFUNCTION(BlueprintCallable)
	void MontageFinished();

	void BreakCombo();
	void SaveNextAttack();

	FORCEINLINE bool IsNextAttackSaved() const { return NextAttack; }
	
private:

	int CurrentComboIndex = 0;
	
	UPROPERTY()
	TObjectPtr<USkeletalMeshComponent> SkeletalMeshComponent;

	UPROPERTY()
	TObjectPtr<UAnimMontage> CurrentMontage;

	UPROPERTY()
	FSequence CurrentComboSequence;

	TObjectPtr<ACF_Character> CharacterCached;
	
	void CheckComboSequence();
	void NormalAttack();
	void Attack(UAnimMontage* AttackMontageToPlay) const;

	bool NextAttack;
};

================
File: CombatFramework/Public/Enums/GameEnums.h
================
// M T All rights Reserved

#pragma once


UENUM(Blueprintable)
enum class ECF_ActionState : uint8
{
	Idle,
	Attack,
	Hit,
	
};

================
File: CombatFramework/Public/Notifiers/ComboTimeNotify.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "ComboTimeNotify.generated.h"

/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UComboTimeNotify : public UAnimNotify
{
	GENERATED_BODY()

public:
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;

};

================
File: CombatFramework/Public/Notifiers/ProperHitNotify.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "ProperHitNotify.generated.h"

/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UProperHitNotify : public UAnimNotify
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Animation)
	TObjectPtr<UAnimMontage> HitMontage;
	
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;
};

================
File: CombatFramework/Public/Notifiers/SwitchActionState.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "Enums/GameEnums.h"
#include "SwitchActionState.generated.h"

/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API USwitchActionState : public UAnimNotify
{
	GENERATED_BODY()

public:
	
	UPROPERTY(EditAnywhere, Category="Player State")
	ECF_ActionState NewState;

	virtual void Notify(USkeletalMeshComponent * MeshComp, UAnimSequenceBase * Animation, const FAnimNotifyEventReference& EventReference) override;
};

================
File: CombatFramework/Public/StateMachines/AI/States/HitAIState.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "Component/CF_StateBase.h"
#include "Structs/GameStructs.h"
#include "HitAIState.generated.h"

class UCF_StateManager;
/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UHitAIState : public UCF_StateBase
{
	GENERATED_BODY()

public:
	ECF_ActionState State = ECF_ActionState::Hit;

	UPROPERTY()
	FHitStateBaseData HitData;
	
	virtual void OnEnterState(AActor* Owner) override;
	virtual void OnExitState() override;

private:
	
	FOnMontageEnded MontageEndedDelegate;
	void OnMontageEnded(UAnimMontage* AnimMontage, bool bInterrupted) const;

};

================
File: CombatFramework/Public/StateMachines/AI/States/IdleAIState.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "Component/CF_StateBase.h"
#include "IdleAIState.generated.h"

class UCF_StateManager;
/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UIdleAIState : public UCF_StateBase
{
	GENERATED_BODY()

public:
	ECF_ActionState State = ECF_ActionState::Idle;

private:
	
};

================
File: CombatFramework/Public/StateMachines/Player/States/AttackPlayerState.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "StateBase.h"
#include "Component/CF_StateBase.h"
#include "Enums/GameEnums.h"
#include "Structs/GameStructs.h"
#include "AttackPlayerState.generated.h"

class ACF_Character;
class UCF_StateManager;
struct FAttackPlayerStateBaseData;
/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UAttackPlayerState : public UCF_StateBase
{
	GENERATED_BODY()

public:

	UAttackPlayerState();

	ECF_ActionState State = ECF_ActionState::Attack;

	UPROPERTY()
	FAttackPlayerStateBaseData AttackData;

	virtual void OnEnterState(AActor* Owner) override;
	virtual void OnExitState() override;

	private:
	
	void OnProperHitCallback(UAnimMontage* HitMontage);
	void OnComboTimeCallback();
	void OnMontageEnded(UAnimMontage* AnimMontage, bool bInterrupted) const;

	UPROPERTY()
	TObjectPtr<ACF_Character> TargetCharacter;

	bool IsAttackContinuing;
	FOnMontageEnded MontageEndedDelegate;

	AActor* GetNearestActorUsingOverlap(const UWorld* World, const FVector& Origin, float Radius, const TSubclassOf<AActor>& ActorClass) const;

	ECollisionEnabled::Type TargetCharacterOldCollision;
	
};

================
File: CombatFramework/Public/StateMachines/Player/States/IdlePlayerState.h
================
// M T All rights Reserved

#pragma once

#include "CoreMinimal.h"
#include "StateBase.h"
#include "Component/CF_StateBase.h"
#include "Enums/GameEnums.h"
#include "IdlePlayerState.generated.h"

class UCF_StateManager;
/**
 * 
 */
UCLASS()
class COMBATFRAMEWORK_API UIdlePlayerState : public UCF_StateBase
{
	GENERATED_BODY()

public:

	UIdlePlayerState();
	
	ECF_ActionState State = ECF_ActionState::Idle;

	virtual void OnEnterState(AActor* Owner) override;
	
};

================
File: CombatFramework/Public/Structs/GameStructs.h
================
#pragma once

#include "GameStructs.generated.h"

USTRUCT()
struct FAttackPlayerStateBaseData
{
	GENERATED_BODY()
	
	UPROPERTY()
	TObjectPtr<UAnimMontage> AttackMontage;
};

USTRUCT()
struct FHitStateBaseData
{
	GENERATED_BODY()

	UPROPERTY()
	TObjectPtr<UAnimMontage> HitMontage;
};

================
File: CombatFramework/Public/Structs/Sequence.h
================
// M T All rights Reserved

#pragma once

#include "Sequence.generated.h"
/**
 * 
 */


USTRUCT(BlueprintType)
struct FSequence : public FTableRowBase
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta=(DisplayName="AttackMontages"))
	TArray<TObjectPtr<UAnimMontage>> AttackMontages;
};

================
File: CombatFrameworkEditor.Target.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class CombatFrameworkEditorTarget : TargetRules
{
	public CombatFrameworkEditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V5;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_4;
		ExtraModuleNames.Add("CombatFramework");
	}
}
